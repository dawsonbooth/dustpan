{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"dustpan \u00b6 Description \u00b6 Clean up your workspace by removing extraneous files and directories. Installation \u00b6 With Python installed, simply run the following command to add the package to your project. 1 python -m pip install dustpan Usage \u00b6 This is a command-line program, and can be executed as follows: 1 dustpan [ -h ] [ -p PATTERNS [ PATTERNS ... ]] [ -i IGNORE [ IGNORE ... ]] [ --remove-empty-directories ] [ -q | -v | -vv ] directories [ directories ... ] Positional arguments: 1 directories Root directories to search Optional arguments: 1 2 3 4 5 6 7 8 9 10 -h, --help show this help message and exit -p PATTERNS [PATTERNS ...], --patterns PATTERNS [PATTERNS ...] Additional path patterns to queue for removal -i IGNORE [IGNORE ...], --ignore IGNORE [IGNORE ...] Path patterns to exclude from removal --remove-empty-directories Remove all childless directories -q, --quiet Be quiet -v, --verbose Be more verbose -vv, --very-verbose Be very verbose Feel free to check out the docs for more information on how to use this package. License \u00b6 This software is released under the terms of MIT license .","title":"Overview"},{"location":"#dustpan","text":"","title":"dustpan"},{"location":"#description","text":"Clean up your workspace by removing extraneous files and directories.","title":"Description"},{"location":"#installation","text":"With Python installed, simply run the following command to add the package to your project. 1 python -m pip install dustpan","title":"Installation"},{"location":"#usage","text":"This is a command-line program, and can be executed as follows: 1 dustpan [ -h ] [ -p PATTERNS [ PATTERNS ... ]] [ -i IGNORE [ IGNORE ... ]] [ --remove-empty-directories ] [ -q | -v | -vv ] directories [ directories ... ] Positional arguments: 1 directories Root directories to search Optional arguments: 1 2 3 4 5 6 7 8 9 10 -h, --help show this help message and exit -p PATTERNS [PATTERNS ...], --patterns PATTERNS [PATTERNS ...] Additional path patterns to queue for removal -i IGNORE [IGNORE ...], --ignore IGNORE [IGNORE ...] Path patterns to exclude from removal --remove-empty-directories Remove all childless directories -q, --quiet Be quiet -v, --verbose Be more verbose -vv, --very-verbose Be very verbose Feel free to check out the docs for more information on how to use this package.","title":"Usage"},{"location":"#license","text":"This software is released under the terms of MIT license .","title":"License"},{"location":"reference/dustpan/","text":"Module dustpan \u00b6 View Source import shutil from pathlib import Path from typing import Iterable , Set DEFAULT_INCLUDE = { \"__pycache__\" , \"*.pyc\" , \"*.pyo\" } DEFAULT_EXCLUDE = { \".venv/**/*\" } def remove_file ( file : Path ) -> None : \"\"\"Remove a file Args: path (Path): The path to the file \"\"\" if file . exists (): file . unlink () def remove_directory ( directory : Path ) -> None : \"\"\"Remove a directory Args: path (Path): The path to the directory \"\"\" if directory . exists (): shutil . rmtree ( directory ) def remove ( path : Path ) -> None : \"\"\"Remove a file or directory Args: path (Path): The path to the file or directory \"\"\" if path . exists (): if path . is_dir (): remove_directory ( path ) else : remove_file ( path ) def search ( * directories : Path , patterns : Iterable [ str ] = DEFAULT_INCLUDE , ignore : Iterable [ str ] = DEFAULT_EXCLUDE ) -> Set [ Path ]: \"\"\"Search for path patterns within directories Args: patterns (Iterable[str], optional): Patterns to glob recursively. Defaults to DEFAULT_PATTERNS. ignore (Iterable[str], optional): Patterns to ignore. Defaults to DEFAULT_IGNORE. Returns: Set[Path]: [description] \"\"\" paths = set () for directory in directories : for pattern in patterns : for path in directory . rglob ( pattern ): if path . exists (): paths . add ( path ) for pattern in ignore : for path in directory . rglob ( pattern ): if path in paths : paths . remove ( path ) return paths __all__ = [ \"remove\" , \"remove_file\" , \"remove_directory\" , \"search\" ] Sub-modules \u00b6 dustpan.config Functions \u00b6 remove \u00b6 1 2 3 def remove ( path : pathlib . Path ) -> None Remove a file or directory Parameters: Name Type Description Default path Path The path to the file or directory None View Source def remove ( path : Path ) -> None : \"\"\"Remove a file or directory Args: path (Path): The path to the file or directory \"\"\" if path . exists () : if path . is_dir () : remove_directory ( path ) else : remove_file ( path ) remove_directory \u00b6 1 2 3 def remove_directory ( directory : pathlib . Path ) -> None Remove a directory Parameters: Name Type Description Default path Path The path to the directory None View Source def remove_directory ( directory : Path ) -> None : \"\"\"Remove a directory Args: path (Path): The path to the directory \"\"\" if directory . exists () : shutil . rmtree ( directory ) remove_file \u00b6 1 2 3 def remove_file ( file : pathlib . Path ) -> None Remove a file Parameters: Name Type Description Default path Path The path to the file None View Source def remove_file ( file : Path ) -> None : \"\"\"Remove a file Args: path (Path): The path to the file \"\"\" if file . exists () : file . unlink () search \u00b6 1 2 3 4 5 def search ( * directories : pathlib . Path , patterns : Iterable [ str ] = { '*.pyc' , '__pycache__' , '*.pyo' }, ignore : Iterable [ str ] = { '.venv/**/*' } ) -> Set [ pathlib . Path ] Search for path patterns within directories Parameters: Name Type Description Default patterns Iterable[str] Patterns to glob recursively. Defaults to DEFAULT_PATTERNS. DEFAULT_PATTERNS ignore Iterable[str] Patterns to ignore. Defaults to DEFAULT_IGNORE. DEFAULT_IGNORE Returns: Type Description Set[Path] [description] View Source def search ( * directories : Path , patterns : Iterable [ str ] = DEFAULT_INCLUDE , ignore : Iterable [ str ] = DEFAULT_EXCLUDE ) -> Set [ Path ] : \"\"\"Search for path patterns within directories Args: patterns (Iterable[str], optional): Patterns to glob recursively. Defaults to DEFAULT_PATTERNS. ignore (Iterable[str], optional): Patterns to ignore. Defaults to DEFAULT_IGNORE. Returns: Set[Path]: [description] \"\"\" paths = set () for directory in directories : for pattern in patterns : for path in directory . rglob ( pattern ) : if path . exists () : paths . add ( path ) for pattern in ignore : for path in directory . rglob ( pattern ) : if path in paths : paths . remove ( path ) return paths","title":"Index"},{"location":"reference/dustpan/#module-dustpan","text":"View Source import shutil from pathlib import Path from typing import Iterable , Set DEFAULT_INCLUDE = { \"__pycache__\" , \"*.pyc\" , \"*.pyo\" } DEFAULT_EXCLUDE = { \".venv/**/*\" } def remove_file ( file : Path ) -> None : \"\"\"Remove a file Args: path (Path): The path to the file \"\"\" if file . exists (): file . unlink () def remove_directory ( directory : Path ) -> None : \"\"\"Remove a directory Args: path (Path): The path to the directory \"\"\" if directory . exists (): shutil . rmtree ( directory ) def remove ( path : Path ) -> None : \"\"\"Remove a file or directory Args: path (Path): The path to the file or directory \"\"\" if path . exists (): if path . is_dir (): remove_directory ( path ) else : remove_file ( path ) def search ( * directories : Path , patterns : Iterable [ str ] = DEFAULT_INCLUDE , ignore : Iterable [ str ] = DEFAULT_EXCLUDE ) -> Set [ Path ]: \"\"\"Search for path patterns within directories Args: patterns (Iterable[str], optional): Patterns to glob recursively. Defaults to DEFAULT_PATTERNS. ignore (Iterable[str], optional): Patterns to ignore. Defaults to DEFAULT_IGNORE. Returns: Set[Path]: [description] \"\"\" paths = set () for directory in directories : for pattern in patterns : for path in directory . rglob ( pattern ): if path . exists (): paths . add ( path ) for pattern in ignore : for path in directory . rglob ( pattern ): if path in paths : paths . remove ( path ) return paths __all__ = [ \"remove\" , \"remove_file\" , \"remove_directory\" , \"search\" ]","title":"Module dustpan"},{"location":"reference/dustpan/#sub-modules","text":"dustpan.config","title":"Sub-modules"},{"location":"reference/dustpan/#functions","text":"","title":"Functions"},{"location":"reference/dustpan/#remove","text":"1 2 3 def remove ( path : pathlib . Path ) -> None Remove a file or directory Parameters: Name Type Description Default path Path The path to the file or directory None View Source def remove ( path : Path ) -> None : \"\"\"Remove a file or directory Args: path (Path): The path to the file or directory \"\"\" if path . exists () : if path . is_dir () : remove_directory ( path ) else : remove_file ( path )","title":"remove"},{"location":"reference/dustpan/#remove_directory","text":"1 2 3 def remove_directory ( directory : pathlib . Path ) -> None Remove a directory Parameters: Name Type Description Default path Path The path to the directory None View Source def remove_directory ( directory : Path ) -> None : \"\"\"Remove a directory Args: path (Path): The path to the directory \"\"\" if directory . exists () : shutil . rmtree ( directory )","title":"remove_directory"},{"location":"reference/dustpan/#remove_file","text":"1 2 3 def remove_file ( file : pathlib . Path ) -> None Remove a file Parameters: Name Type Description Default path Path The path to the file None View Source def remove_file ( file : Path ) -> None : \"\"\"Remove a file Args: path (Path): The path to the file \"\"\" if file . exists () : file . unlink ()","title":"remove_file"},{"location":"reference/dustpan/#search","text":"1 2 3 4 5 def search ( * directories : pathlib . Path , patterns : Iterable [ str ] = { '*.pyc' , '__pycache__' , '*.pyo' }, ignore : Iterable [ str ] = { '.venv/**/*' } ) -> Set [ pathlib . Path ] Search for path patterns within directories Parameters: Name Type Description Default patterns Iterable[str] Patterns to glob recursively. Defaults to DEFAULT_PATTERNS. DEFAULT_PATTERNS ignore Iterable[str] Patterns to ignore. Defaults to DEFAULT_IGNORE. DEFAULT_IGNORE Returns: Type Description Set[Path] [description] View Source def search ( * directories : Path , patterns : Iterable [ str ] = DEFAULT_INCLUDE , ignore : Iterable [ str ] = DEFAULT_EXCLUDE ) -> Set [ Path ] : \"\"\"Search for path patterns within directories Args: patterns (Iterable[str], optional): Patterns to glob recursively. Defaults to DEFAULT_PATTERNS. ignore (Iterable[str], optional): Patterns to ignore. Defaults to DEFAULT_IGNORE. Returns: Set[Path]: [description] \"\"\" paths = set () for directory in directories : for pattern in patterns : for path in directory . rglob ( pattern ) : if path . exists () : paths . add ( path ) for pattern in ignore : for path in directory . rglob ( pattern ) : if path in paths : paths . remove ( path ) return paths","title":"search"},{"location":"reference/dustpan/config/","text":"Module dustpan.config \u00b6 View Source from __future__ import annotations import argparse import enum import os from dataclasses import dataclass from pathlib import Path from typing import Iterable , Set , Union import toml CWD = Path . cwd () class Verbosity ( enum . IntEnum ): QUIET = 0 NORMAL = 1 VERBOSE = 2 VERY_VERBOSE = 3 @dataclass class Configuration : directories : Set [ Path ] include : Set [ str ] exclude : Set [ str ] remove_empty_directories : bool verbosity : Verbosity def __init__ ( self , directories : Iterable [ Union [ os . PathLike , str ]] = { CWD }, include : Iterable [ str ] = set (), exclude : Iterable [ str ] = set (), remove_empty_directories : bool = False , quiet : bool = False , verbose : bool = False , very_verbose : bool = False , ) -> None : self . directories = set ( map ( lambda p : Path ( p ) . resolve (), directories )) self . include = set ( include ) self . exclude = set ( exclude ) self . remove_empty_directories = remove_empty_directories if quiet : self . verbosity = Verbosity . QUIET elif verbose : self . verbosity = Verbosity . VERBOSE elif very_verbose : self . verbosity = Verbosity . VERY_VERBOSE else : self . verbosity = Verbosity . NORMAL def parse_pyproject_toml () -> dict : pyproject_toml = toml . load ( CWD / \"pyproject.toml\" ) config : dict = pyproject_toml . get ( \"tool\" , {}) . get ( \"dustpan\" , {}) return { k . replace ( \"-\" , \"_\" ): v for k , v in config . items ()} def parse_arguments () -> dict : parser = argparse . ArgumentParser ( description = \"\" ) parser . add_argument ( \"directories\" , type = Path , nargs = \"+\" , help = \"Root directories to search\" ) parser . add_argument ( \"-p\" , \"--patterns\" , type = str , nargs = \"+\" , help = \"Additional path patterns to queue for removal\" ) parser . add_argument ( \"-i\" , \"--ignore\" , type = str , nargs = \"+\" , help = \"Path patterns to exclude from removal\" ) parser . add_argument ( \"--remove-empty-directories\" , action = \"store_true\" , help = \"Remove all childless directories\" ) verbosity = parser . add_mutually_exclusive_group () verbosity . add_argument ( \"-q\" , \"--quiet\" , action = \"store_true\" , help = \"Be quiet\" ) verbosity . add_argument ( \"-v\" , \"--verbose\" , action = \"store_true\" , help = \"Be more verbose\" ) verbosity . add_argument ( \"-vv\" , \"--very-verbose\" , action = \"store_true\" , help = \"Be very verbose\" ) args = parser . parse_args () return { k : v for k , v in vars ( args ) . items () if bool ( v )} CONFIG = Configuration ( ** { ** parse_pyproject_toml (), ** parse_arguments ()}) Variables \u00b6 1 CONFIG 1 CWD Functions \u00b6 parse_arguments \u00b6 1 2 3 def parse_arguments ( ) -> 'dict' View Source def parse_arguments () -> dict : parser = argparse . ArgumentParser ( description = \"\" ) parser . add_argument ( \"directories\" , type = Path , nargs = \"+\" , help = \"Root directories to search\" ) parser . add_argument ( \"-p\" , \"--patterns\" , type = str , nargs = \"+\" , help = \"Additional path patterns to queue for removal\" ) parser . add_argument ( \"-i\" , \"--ignore\" , type = str , nargs = \"+\" , help = \"Path patterns to exclude from removal\" ) parser . add_argument ( \"--remove-empty-directories\" , action = \"store_true\" , help = \"Remove all childless directories\" ) verbosity = parser . add_mutually_exclusive_group () verbosity . add_argument ( \"-q\" , \"--quiet\" , action = \"store_true\" , help = \"Be quiet\" ) verbosity . add_argument ( \"-v\" , \"--verbose\" , action = \"store_true\" , help = \"Be more verbose\" ) verbosity . add_argument ( \"-vv\" , \"--very-verbose\" , action = \"store_true\" , help = \"Be very verbose\" ) args = parser . parse_args () return { k : v for k , v in vars ( args ) . items () if bool ( v )} parse_pyproject_toml \u00b6 1 2 3 def parse_pyproject_toml ( ) -> 'dict' View Source def parse_pyproject_toml () -> dict : pyproject_toml = toml . load ( CWD / \"pyproject.toml\" ) config : dict = pyproject_toml . get ( \"tool\" , {}) . get ( \"dustpan\" , {}) return { k . replace ( \"-\" , \"_\" ): v for k , v in config . items ()} Classes \u00b6 Configuration \u00b6 1 2 3 4 5 6 7 8 9 class Configuration ( directories : 'Iterable[Union[os.PathLike, str]]' = { PosixPath ( '/home/runner/work/dustpan/dustpan' )}, include : 'Iterable[str]' = set (), exclude : 'Iterable[str]' = set (), remove_empty_directories : 'bool' = False , quiet : 'bool' = False , verbose : 'bool' = False , very_verbose : 'bool' = False ) Configuration(directories: 'Iterable[Union[os.PathLike, str]]' = {PosixPath('/home/runner/work/dustpan/dustpan')}, include: 'Iterable[str]' = set(), exclude: 'Iterable[str]' = set(), remove_empty_directories: 'bool' = False, quiet: 'bool' = False, verbose: 'bool' = False, very_verbose: 'bool' = False) -> 'None' View Source @dataclass class Configuration : directories : Set [ Path ] include : Set [ str ] exclude : Set [ str ] remove_empty_directories : bool verbosity : Verbosity def __init__ ( self , directories : Iterable [ Union[os.PathLike, str ] ] = { CWD } , include : Iterable [ str ] = set (), exclude : Iterable [ str ] = set (), remove_empty_directories : bool = False , quiet : bool = False , verbose : bool = False , very_verbose : bool = False , ) -> None : self . directories = set ( map ( lambda p : Path ( p ). resolve (), directories )) self . include = set ( include ) self . exclude = set ( exclude ) self . remove_empty_directories = remove_empty_directories if quiet : self . verbosity = Verbosity . QUIET elif verbose : self . verbosity = Verbosity . VERBOSE elif very_verbose : self . verbosity = Verbosity . VERY_VERBOSE else : self . verbosity = Verbosity . NORMAL Verbosity \u00b6 1 2 3 4 class Verbosity ( * args , ** kwds ) Enum where members are also (and must be) ints View Source class Verbosity ( enum . IntEnum ): QUIET = 0 NORMAL = 1 VERBOSE = 2 VERY_VERBOSE = 3 Ancestors (in MRO) \u00b6 enum.IntEnum builtins.int enum.ReprEnum enum.Enum Class variables \u00b6 1 NORMAL 1 QUIET 1 VERBOSE 1 VERY_VERBOSE 1 denominator 1 imag 1 numerator 1 real Methods \u00b6 as_integer_ratio \u00b6 1 2 3 4 def as_integer_ratio ( self , / ) Return integer ratio. Return a pair of integers, whose ratio is exactly equal to the original int and with a positive denominator. (10).as_integer_ratio() (10, 1) (-10).as_integer_ratio() (-10, 1) (0).as_integer_ratio() (0, 1) bit_count \u00b6 1 2 3 4 def bit_count ( self , / ) Number of ones in the binary representation of the absolute value of self. Also known as the population count. bin(13) '0b1101' (13).bit_count() 3 bit_length \u00b6 1 2 3 4 def bit_length ( self , / ) Number of bits necessary to represent self in binary. bin(37) '0b100101' (37).bit_length() 6 conjugate \u00b6 1 2 3 def conjugate ( ... ) Returns self, the complex conjugate of any int. from_bytes \u00b6 1 2 3 4 5 6 def from_bytes ( bytes , byteorder = 'big' , * , signed = False ) Return the integer represented by the given array of bytes. bytes Holds the array of bytes to convert. The argument must either support the buffer protocol or be an iterable object producing bytes. Bytes and bytearray are examples of built-in objects that support the buffer protocol. byteorder The byte order used to represent the integer. If byteorder is 'big', the most significant byte is at the beginning of the byte array. If byteorder is 'little', the most significant byte is at the end of the byte array. To request the native byte order of the host system, use `sys.byteorder' as the byte order value. Default is to use 'big'. signed Indicates whether two's complement is used to represent the integer. to_bytes \u00b6 1 2 3 4 5 6 7 8 def to_bytes ( self , / , length = 1 , byteorder = 'big' , * , signed = False ) Return an array of bytes representing an integer. length Length of bytes object to use. An OverflowError is raised if the integer is not representable with the given number of bytes. Default is length 1. byteorder The byte order used to represent the integer. If byteorder is 'big', the most significant byte is at the beginning of the byte array. If byteorder is 'little', the most significant byte is at the end of the byte array. To request the native byte order of the host system, use `sys.byteorder' as the byte order value. Default is to use 'big'. signed Determines whether two's complement is used to represent the integer. If signed is False and a negative integer is given, an OverflowError is raised.","title":"Config"},{"location":"reference/dustpan/config/#module-dustpanconfig","text":"View Source from __future__ import annotations import argparse import enum import os from dataclasses import dataclass from pathlib import Path from typing import Iterable , Set , Union import toml CWD = Path . cwd () class Verbosity ( enum . IntEnum ): QUIET = 0 NORMAL = 1 VERBOSE = 2 VERY_VERBOSE = 3 @dataclass class Configuration : directories : Set [ Path ] include : Set [ str ] exclude : Set [ str ] remove_empty_directories : bool verbosity : Verbosity def __init__ ( self , directories : Iterable [ Union [ os . PathLike , str ]] = { CWD }, include : Iterable [ str ] = set (), exclude : Iterable [ str ] = set (), remove_empty_directories : bool = False , quiet : bool = False , verbose : bool = False , very_verbose : bool = False , ) -> None : self . directories = set ( map ( lambda p : Path ( p ) . resolve (), directories )) self . include = set ( include ) self . exclude = set ( exclude ) self . remove_empty_directories = remove_empty_directories if quiet : self . verbosity = Verbosity . QUIET elif verbose : self . verbosity = Verbosity . VERBOSE elif very_verbose : self . verbosity = Verbosity . VERY_VERBOSE else : self . verbosity = Verbosity . NORMAL def parse_pyproject_toml () -> dict : pyproject_toml = toml . load ( CWD / \"pyproject.toml\" ) config : dict = pyproject_toml . get ( \"tool\" , {}) . get ( \"dustpan\" , {}) return { k . replace ( \"-\" , \"_\" ): v for k , v in config . items ()} def parse_arguments () -> dict : parser = argparse . ArgumentParser ( description = \"\" ) parser . add_argument ( \"directories\" , type = Path , nargs = \"+\" , help = \"Root directories to search\" ) parser . add_argument ( \"-p\" , \"--patterns\" , type = str , nargs = \"+\" , help = \"Additional path patterns to queue for removal\" ) parser . add_argument ( \"-i\" , \"--ignore\" , type = str , nargs = \"+\" , help = \"Path patterns to exclude from removal\" ) parser . add_argument ( \"--remove-empty-directories\" , action = \"store_true\" , help = \"Remove all childless directories\" ) verbosity = parser . add_mutually_exclusive_group () verbosity . add_argument ( \"-q\" , \"--quiet\" , action = \"store_true\" , help = \"Be quiet\" ) verbosity . add_argument ( \"-v\" , \"--verbose\" , action = \"store_true\" , help = \"Be more verbose\" ) verbosity . add_argument ( \"-vv\" , \"--very-verbose\" , action = \"store_true\" , help = \"Be very verbose\" ) args = parser . parse_args () return { k : v for k , v in vars ( args ) . items () if bool ( v )} CONFIG = Configuration ( ** { ** parse_pyproject_toml (), ** parse_arguments ()})","title":"Module dustpan.config"},{"location":"reference/dustpan/config/#variables","text":"1 CONFIG 1 CWD","title":"Variables"},{"location":"reference/dustpan/config/#functions","text":"","title":"Functions"},{"location":"reference/dustpan/config/#parse_arguments","text":"1 2 3 def parse_arguments ( ) -> 'dict' View Source def parse_arguments () -> dict : parser = argparse . ArgumentParser ( description = \"\" ) parser . add_argument ( \"directories\" , type = Path , nargs = \"+\" , help = \"Root directories to search\" ) parser . add_argument ( \"-p\" , \"--patterns\" , type = str , nargs = \"+\" , help = \"Additional path patterns to queue for removal\" ) parser . add_argument ( \"-i\" , \"--ignore\" , type = str , nargs = \"+\" , help = \"Path patterns to exclude from removal\" ) parser . add_argument ( \"--remove-empty-directories\" , action = \"store_true\" , help = \"Remove all childless directories\" ) verbosity = parser . add_mutually_exclusive_group () verbosity . add_argument ( \"-q\" , \"--quiet\" , action = \"store_true\" , help = \"Be quiet\" ) verbosity . add_argument ( \"-v\" , \"--verbose\" , action = \"store_true\" , help = \"Be more verbose\" ) verbosity . add_argument ( \"-vv\" , \"--very-verbose\" , action = \"store_true\" , help = \"Be very verbose\" ) args = parser . parse_args () return { k : v for k , v in vars ( args ) . items () if bool ( v )}","title":"parse_arguments"},{"location":"reference/dustpan/config/#parse_pyproject_toml","text":"1 2 3 def parse_pyproject_toml ( ) -> 'dict' View Source def parse_pyproject_toml () -> dict : pyproject_toml = toml . load ( CWD / \"pyproject.toml\" ) config : dict = pyproject_toml . get ( \"tool\" , {}) . get ( \"dustpan\" , {}) return { k . replace ( \"-\" , \"_\" ): v for k , v in config . items ()}","title":"parse_pyproject_toml"},{"location":"reference/dustpan/config/#classes","text":"","title":"Classes"},{"location":"reference/dustpan/config/#configuration","text":"1 2 3 4 5 6 7 8 9 class Configuration ( directories : 'Iterable[Union[os.PathLike, str]]' = { PosixPath ( '/home/runner/work/dustpan/dustpan' )}, include : 'Iterable[str]' = set (), exclude : 'Iterable[str]' = set (), remove_empty_directories : 'bool' = False , quiet : 'bool' = False , verbose : 'bool' = False , very_verbose : 'bool' = False ) Configuration(directories: 'Iterable[Union[os.PathLike, str]]' = {PosixPath('/home/runner/work/dustpan/dustpan')}, include: 'Iterable[str]' = set(), exclude: 'Iterable[str]' = set(), remove_empty_directories: 'bool' = False, quiet: 'bool' = False, verbose: 'bool' = False, very_verbose: 'bool' = False) -> 'None' View Source @dataclass class Configuration : directories : Set [ Path ] include : Set [ str ] exclude : Set [ str ] remove_empty_directories : bool verbosity : Verbosity def __init__ ( self , directories : Iterable [ Union[os.PathLike, str ] ] = { CWD } , include : Iterable [ str ] = set (), exclude : Iterable [ str ] = set (), remove_empty_directories : bool = False , quiet : bool = False , verbose : bool = False , very_verbose : bool = False , ) -> None : self . directories = set ( map ( lambda p : Path ( p ). resolve (), directories )) self . include = set ( include ) self . exclude = set ( exclude ) self . remove_empty_directories = remove_empty_directories if quiet : self . verbosity = Verbosity . QUIET elif verbose : self . verbosity = Verbosity . VERBOSE elif very_verbose : self . verbosity = Verbosity . VERY_VERBOSE else : self . verbosity = Verbosity . NORMAL","title":"Configuration"},{"location":"reference/dustpan/config/#verbosity","text":"1 2 3 4 class Verbosity ( * args , ** kwds ) Enum where members are also (and must be) ints View Source class Verbosity ( enum . IntEnum ): QUIET = 0 NORMAL = 1 VERBOSE = 2 VERY_VERBOSE = 3","title":"Verbosity"},{"location":"reference/dustpan/config/#ancestors-in-mro","text":"enum.IntEnum builtins.int enum.ReprEnum enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/dustpan/config/#class-variables","text":"1 NORMAL 1 QUIET 1 VERBOSE 1 VERY_VERBOSE 1 denominator 1 imag 1 numerator 1 real","title":"Class variables"},{"location":"reference/dustpan/config/#methods","text":"","title":"Methods"},{"location":"reference/dustpan/config/#as_integer_ratio","text":"1 2 3 4 def as_integer_ratio ( self , / ) Return integer ratio. Return a pair of integers, whose ratio is exactly equal to the original int and with a positive denominator. (10).as_integer_ratio() (10, 1) (-10).as_integer_ratio() (-10, 1) (0).as_integer_ratio() (0, 1)","title":"as_integer_ratio"},{"location":"reference/dustpan/config/#bit_count","text":"1 2 3 4 def bit_count ( self , / ) Number of ones in the binary representation of the absolute value of self. Also known as the population count. bin(13) '0b1101' (13).bit_count() 3","title":"bit_count"},{"location":"reference/dustpan/config/#bit_length","text":"1 2 3 4 def bit_length ( self , / ) Number of bits necessary to represent self in binary. bin(37) '0b100101' (37).bit_length() 6","title":"bit_length"},{"location":"reference/dustpan/config/#conjugate","text":"1 2 3 def conjugate ( ... ) Returns self, the complex conjugate of any int.","title":"conjugate"},{"location":"reference/dustpan/config/#from_bytes","text":"1 2 3 4 5 6 def from_bytes ( bytes , byteorder = 'big' , * , signed = False ) Return the integer represented by the given array of bytes. bytes Holds the array of bytes to convert. The argument must either support the buffer protocol or be an iterable object producing bytes. Bytes and bytearray are examples of built-in objects that support the buffer protocol. byteorder The byte order used to represent the integer. If byteorder is 'big', the most significant byte is at the beginning of the byte array. If byteorder is 'little', the most significant byte is at the end of the byte array. To request the native byte order of the host system, use `sys.byteorder' as the byte order value. Default is to use 'big'. signed Indicates whether two's complement is used to represent the integer.","title":"from_bytes"},{"location":"reference/dustpan/config/#to_bytes","text":"1 2 3 4 5 6 7 8 def to_bytes ( self , / , length = 1 , byteorder = 'big' , * , signed = False ) Return an array of bytes representing an integer. length Length of bytes object to use. An OverflowError is raised if the integer is not representable with the given number of bytes. Default is length 1. byteorder The byte order used to represent the integer. If byteorder is 'big', the most significant byte is at the beginning of the byte array. If byteorder is 'little', the most significant byte is at the end of the byte array. To request the native byte order of the host system, use `sys.byteorder' as the byte order value. Default is to use 'big'. signed Determines whether two's complement is used to represent the integer. If signed is False and a negative integer is given, an OverflowError is raised.","title":"to_bytes"}]}